Andr√©'s GitHub Identification Script AndreGitHubID_script-1.Rmd
====================================================================================================

Setting things up:
Installing the required packages for R: This is to be done in the R command line and not in R studio
source("http://www.Bioconductor.org/biocLite.R") 
biocLite("BiocUpgrade")

Getting started in R: Set the working directory

Add evniroment details to allow qsub submission from within RStudio:
```{r}
Sys.setenv(SGE_ROOT="/opt/gridengine")
# Sys.setenv(SGE_CELL="default")
Sys.setenv(SGE_ARCH="linux-x64")
Sys.setenv(SGE_EXECD_PORT="537")
Sys.setenv(SGE_QMASTER_PORT="536")
```

Install and load necessary packages
```{r}
install.packages("rentrez")
install.packages("xlsx")
install.packages("ape")
install.packages("seqinr")
install.packages("chemometrics")
```

Keep the library() loading separate from the install.packages chunk
```{r}
library(knitr)
library("xlsx")
library("ape")
library(Biostrings)
```

Generating a function to make qsub jobs and a bash script to submit them: "need to figure out a 
way to get the log files sent to the prefix folder"
```{r}
# This makes a function that generates qsub commands and a bash to submit them in parallel on 
# processors on the biocluster using 3 inputs (will be used often throughout the script whenever a
# Linux command needs to be done on several data files)

MakeQsubs <- function(cmd, prefix, suffix = ".sub", node =1) {
  dir.create(paste(sharedPathAn, prefix, sep = ""), 
             showWarnings = TRUE, 
             recursive = FALSE)
  outPath <- paste(sharedPathAn, prefix, "/", sep="")
  for(k in 1:length(cmd)) {
    cat(paste("#!/bin/bash \n",
              "#$ -S /bin/bash
              # Ensure .e and .o and other output files go to working directory
              #$ -cwd
              # Request one slot in the smp environment
              #$ -pe smp ", node, "\n",
              "# Actual linux command for qsub \n",
              cmd[k],
              sep=""),
        file=paste(outPath, prefix, k, suffix, sep="")
        )
  }
  # make a bash script to run all qsub
  cat(paste("#!/bin/bash
            #$ -S /bin/bash
            argc=$#
            requiredArgc=0
            if [ $argc -ne $requiredArgc ]; then
            echo './test_mkdir.sh'
            exit 1
            fi

            prefixInFiles=", prefix, "\n",
            "suffixInFiles=", suffix, "\n",
            "for (( i = 1; i <= ", length(cmd), " ; i++ )); do 
            # keep track of what is going on...
            echo 'Treating file'  $prefixInFiles$i$suffixInFiles
            # define a script name that will be submited to the queue
            qsubFile=$prefixInFiles$i$suffixInFiles
            # make the script executable
            chmod a+x $qsubFile
            # submit the script to the queue
            qsub -cwd $qsubFile
            done", sep=""), 
      file=paste(outPath, prefix, ".sh", sep=""))
  cat(c("\n"," *** SUBMIT FOLLOWING TWO COMMANDS FROM HEADNODE ***","\n",
        "    1- Ensure working directory given for outputs:", "\n",
        paste("cd", outPath), "\n",
        "    2- Run the bash from within this working directory:", "\n",
        paste("bash ", prefix, ".sh", sep="")))
}
# End of qsub and bash making function
```

```{r}
bashDirections <- paste("
'###############################################################################
 ##### ***** SUBMIT BASH FILE FROM HEAD NODE, AND WAIT FOR COMPLETION ****######
 #####          watch output from this command in the console             ######
 ###############################################################################'")
cat(bashDirections)
```

Function to remove output files after running qsubs:
```{r}
RemoveQsubTempFiles <- function(path, prefixSub) {
  system(paste("find ", path, prefixSub, "/", prefixSub, "*", ".sub.", "*", " -delete ", sep = ""))
}
```


Record the folder where fasta file is (there should be only one)
```{r}
sharedPath   <- "/home/CFIA-ACIA/girouxeml/PIRL_working_directory/"
sharedPathAn <- paste(sharedPath, "output/", sep = "")
setwd(sharedPath)
idFolder  <- "Helotiales_ITS/"
dir.create(paste("", idFolder, sep = ""), 
           showWarnings = TRUE,
           recursive    = FALSE)

dir.create(paste("", idFolder, "/", "GenBank/", sep = ""), 
           showWarnings = TRUE,
           recursive    = FALSE)

genBankPath <- paste(sharedPath, idFolder, "GenBank/", sep = "")
```

Option A: 1 starting sequence
If I want to run this script with only 1 starting sequence:
Specify Folder, read it, rename the sequence if necessary, and put that into the fasta for genBank
variable.
```{r}
lachWiiITSFasta <- paste(sharedPath, 
                         "data/Lachnellula_willkommii/Final_Sequences/ITS_Consensus.fasta",
                         sep = "")
lachWiiITS        <- readAAStringSet(paste(lachWiiITSFasta), format = "fasta")
names(lachWiiITS) <- "Lachnellula_willkommii-ITS"
fastaForGenBank   <- lachWiiITS
```

Option B: >1 Starting sequences

Find the fasta file(s)
```{r}
idFastaFiles <- list.files(path = paste(sharedPath, idFolder, sep = ""), 
                           pattern = "\\.fas$|\\.fasta$", 
                           recursive = FALSE)
```

Pick the right file(s)
```{r}
idFastaFiles
idFastaFiles <- idFastaFiles[6] # If I only want this one
idFastaFiles
```

If you have more than one fasta file, put all of your files into one bigger fasta file:
```{r}
cmd <- paste(" cat ", paste(sharedPath, idFolder, as.character(idFastaFiles), 
                            collapse = " ", sep = ""),
             " > ", paste(sharedPath, idFolder, "query.fasta", sep = ""),
             sep = "")

system(cmd)

idFastaFiles <- paste(sharedPath, idFolder, "query.fasta", sep = "")

# If you have only the one file and don't need to combine into a bigger file, set the path manually:
idFastaFiles <- paste(sharedPath, idFolder, idFastaFiles, sep = "")

```


Do a MAFFT alignment, linsi coomand:
```{r}

prefix    <- "A_original_query_First_MAFFT_linsi_Alignment"
linsiPath <- "/opt/bio/mafft/bin/linsi"


cmd <- paste(linsiPath, 
             " --reorder '", idFastaFiles,
             "' > ", paste(sharedPath, idFolder, "query_aligned_fasta.fasta", sep = ""),
             sep = "")

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)

```

Check if the qsub job is still running:
```{r}
system("/opt/gridengine/bin/linux-x64/qstat")
```

Clean-up step: Remove the output files while keeping the qsub and bash file:
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

Trim the alignment:
```{r}
library("ape")

align <- read.dna(paste(sharedPath, idFolder, "query_aligned_fasta.fasta", sep = ""), 
                  format = "fasta")
dm    <- dist.dna(align, model = "raw", pairwise.deletion = TRUE, as.matrix = TRUE)
tree  <- njs(dm)
maxV  <- max(rowSums(dm), na.rm = TRUE)

```

To get the root of the tree with the most distant species:
```{r}

myRoot <- which(rowSums(dm) == maxV)
max(dm, na.rm = TRUE)
nrow(dm)
pdf(file = paste(sharedPath, idFolder, "/", "NJ_tree_of_ID.pdf", sep = ""), width = 8, height = 14 )
plot.phylo(type = "phylogram", root(tree, myRoot[1], node = NULL, resolve.root = TRUE), 
           font = 1, cex = 0.52,  x.lim = 1 , edge.width = 1.1 , no.margin = TRUE)
title(main = "NJ", outer = FALSE, cex.main = 1, font.main = 2)
dev.off() 
```

Setting things up to get the number of blasts required for the tree:
```{r}
tree[[1]]
dm <- dist.dna(align, model = "raw", pairwise.deletion = FALSE, as.matrix = TRUE)
tree <- njs(dm)

pdf(file = paste(sharedPath, idFolder, "/", "NJ_tree_of_ID_for_how_many_blasts.pdf", sep = ""), 
    width = 8, height = 14 )

plot.phylo(type = "phylogram", root(tree, myRoot[1], node = NULL, resolve.root = TRUE), 
           font = 1, cex = 0.52 - (sqrt(nrow(dm))/70),  x.lim = 0.07 + max(dm, na.rm = TRUE)/1.3, 
           edge.width = 1.1 - (nrow(dm)/1200), no.margin = TRUE)

title(main = "NJ", outer = FALSE, cex.main = 1, font.main = 2)

dev.off()

dm <- dist.dna(align, model = "raw", pairwise.deletion = FALSE, as.matrix = FALSE)
fit <- hclust(dm, method = "average")

```

Number of groups based on NJ tree
```{r}

numClades <- 5 # based on the number of objects, see fit

groups <- cutree(fit, numClades)
group2 <- data.frame(names(groups), groups, stringsAsFactors = FALSE)

```

Create text file from alignment
```{r}
alignTxt <- sapply(align , function(x) toString(x))

# Remove all gaps, commas, and spaces
alignTxt <- as.character(gsub("-|,| ", "", alignTxt))
alignLength <- sapply(alignTxt , function(x) nchar(x))
group3 <- cbind(group2, alignLength, alignTxt)
group3$alignTxt <- as.character(group3$alignTxt)
```

Create a table of the different cluster with the maximum sequence length for each
```{r}
maxima <- aggregate(alignLength ~ groups, data = group3[,c(2:3)], max)

i <- 1

# Pulls out a vector with a sequence name for each maximu (pulls out the first sequence when more 
# than one have the same max length)

maximaByGroup <- vector()

for(i in 1:nrow(maxima)) {
  temp1 <- subset(group3[,c(1:3)], 
                  group3$groups == maxima$groups[i] & group3$alignLength == maxima$alignLength[i])
  temp2 <- temp1$names.groups.[!duplicated(temp1$alignLength)]
  maximaByGroup <- c(maximaByGroup, temp2)
}

sapply(group3, class)

```

Generate a fasta file that will be used to blast GenBank:
```{r}

fastaForGenBank <- group3[maximaByGroup,c(1,4)]

```

Write fasta file from the table text created to calculate length:
```{r}
library(seqinr)

write.fasta(sequences = as.list(fastaForGenBank[,2]), names = rownames(fastaForGenBank), nbchar = 80, 
            file.out  = paste(sharedPath, idFolder, "GenBank/fasta_for_GenBank.fasta", sep = ""), 
            open = "w")

fastaForGenBankPath <- paste(genBankPath, "fasta_for_GenBank.fasta", sep = "")

```

Blast to get related ITS sequences 
```{r}
library("rentrez")

# query <- "(Helotiales[ORGN] OR Sclerotinia[ORGN] OR Phialocephala[ORGN] OR Marssonina[ORGN] 
#            OR Lachnellula[ORGN] AND (rRNA[Feature] OR misc_RNA[Feature])) 
#            NOT(environmental samples[organism] OR metagenomes[orgn] OR unidentified[orgn])"
query <- "(Helotiales[ORGN] AND (rRNA[Feature] OR misc_RNA[Feature])) 
           NOT(environmental samples[organism] OR metagenomes[orgn] OR unidentified[orgn])"
webEnvSearch <- entrez_search(db="nuccore", query, retmax=999999)

webEnvSearch

length(webEnvSearch$ids)

write.table(webEnvSearch$ids, file = paste(genBankPath, "gilist.txt", sep = ""), 
            append = FALSE, 
            quote  = FALSE, 
            row.names = FALSE, 
            col.names = FALSE)

outfmtCols <- c("qseqid",   "sallacc", "pident", "length", 
                "mismatch", "gapopen", "qstart", "qend", 
                "sstart",   "send",    "evalue", "bitscore")
pathBlastn    <- "/opt/bio/ncbi-blast+/bin/blastn"
pathBlastDbNt <- "/isilon/biodiversity/reference/ncbi/blastdb/reference/nt/nt"
maxTargetSeqs <- 400
dustBlastn    <- "no"
gapOpen       <- 1
gapExtend     <- 1
xDropGap      <- 30
xDropGapFinal <- 100

```


```{r}

prefix <- "B_firstBlast"

cmd <- paste(pathBlastn, 
             " -db ", pathBlastDbNt,
             " -query ", fastaForGenBankPath,
             " -max_target_seqs ", maxTargetSeqs,
             " -gilist ", paste(genBankPath, "gilist.txt", sep = ""),
             " -gapopen ", gapOpen,
             " -gapextend ", gapExtend,
             " -xdrop_gap ", xDropGap,
             " -xdrop_gap_final ", xDropGapFinal,
             " -dust ", dustBlastn,
             " -outfmt '6 ", paste(outfmtCols, collapse = " "),
             " ' -out ", paste(genBankPath, "fasta_for_GenBank.fasta.out", sep = ""), 
             sep = "")


suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

Check if the qsub job is still running:
```{r}

system("/opt/gridengine/bin/linux-x64/qstat")

```


Clean-up step: Remove the output files while keeping the qsub and bash file:
```{r}

RemoveQsubTempFiles(sharedPathAn, prefix)

```

Read and consolitdates BLAST outputs
```{r}
library("seqinr")

gbBlastTable <- read.table(paste(genBankPath, "fasta_for_GenBank.fasta.out", sep = ""), 
                           header = FALSE, 
                           stringsAsFactors = FALSE)

colnames(gbBlastTable) <- c("query_id",   "subject_ids", " %identity", "alignment_length", 
                            "mismatches", "gap_opens",   "q_start",    " q_end", 
                            "s_start",    "s_end",       "evalue",     " bit_score")

# to break multiple gi numbers/ accessions from NCBI table
multiGI <- cbind(gregexpr(";", gbBlastTable$subject_ids, 
                          ignore.case = FALSE, 
                          perl        = FALSE, 
                          fixed       = FALSE, 
                          useBytes    = FALSE))

newGbBlastTable <- data.frame()

for(i in 1:nrow(gbBlastTable)) { 
    if (unlist(multiGI[i])[1] != -1) { 
        parsedNames <- strsplit(as.character(gbBlastTable$subject_ids[i]), ";")[[1]]  # [[1]] to show first element 
        tempTable   <- do.call("rbind", replicate((length(unlist(multiGI[i])) + 1), 
                                                   gbBlastTable[i,], simplify = FALSE)) 
        tempTable$subject_ids <- parsedNames 
        newGbBlastTable <- rbind(newGbBlastTable, tempTable) 
        } else { 
            newGbBlastTable <-  rbind(newGbBlastTable, gbBlastTable[i,]) 
            } 
    }

gbBlastTable <- newGbBlastTable 
summary(gbBlastTable)
colnames(gbBlastTable)[2] <- "GB_accession"
uniqueGB <- unique(gbBlastTable$GB_accession)
```


```{r}
library("ape")
sequences <- read.GenBank(uniqueGB, 
                          seq.names = uniqueGB, 
                          species.names = TRUE,
                          gene.names    = FALSE, 
                          as.character  = TRUE)

sequenceOrder <- sequences[order(names(sequences))]
names(sequenceOrder)[1]
attr(sequences, "species")

fullNames <- data.frame(attr(sequences, "species"), names(sequences), stringsAsFactors = FALSE)
fullNames$SpStrain <-  do.call(paste, c(fullNames[1:2], sep = "_"))
fullNamesOrdered   <- fullNames[order(fullNames$names.sequences.),] 
nrow(fullNamesOrdered)

```


```{r}
library(Biostrings)

gbDNAstring <- DNAStringSet()

for(i in 1:length(sequenceOrder)) { 
    temp <- DNAStringSet(paste(sequenceOrder[[i]], collapse = "")) 
    names(temp)  <- fullNamesOrdered$SpStrain[i] 
    gbDNAstring  <- c(gbDNAstring, temp)
} 

# Creates a +/- column for orientation of sequences
gbBlastTable$orientation <- sign(gbBlastTable$s_end - gbBlastTable$s_start)
gbBlastTable$length      <- abs(gbBlastTable$s_end - gbBlastTable$s_start)
gbBlastTable$query_id    <- as.character(gbBlastTable$query_id)

# Put together data from multiple hits on single line
dataAgg <- aggregate(gbBlastTable[c(2:14)], 
                     by  = list(gbBlastTable$GB_accession, gbBlastTable$GB_accession),
                     FUN = c)

# find min and max and sense of hits
for(i in 1:nrow(dataAgg)) {
  dataAgg$min[i] <- min(unlist(c(dataAgg$s_start[i],dataAgg$s_end[i])))
  dataAgg$max[i] <- max(unlist(c(dataAgg$s_start[i],dataAgg$s_end[i])))
  dataAgg$sense[i] <- mean(unlist(c(dataAgg$orientation[i]))) 
}


# add a column with bp (width) of sequences.
dataAgg$bp    <- width(gbDNAstring)
dataAgg$width <- dataAgg$max - dataAgg$min
dataAgg$diff  <- dataAgg$width - dataAgg$max
dataAgg       <- dataAgg[order(as.character(dataAgg$Group.1)), ] 

# to make sure that name order are the same
checkOrder <- data.frame(names(gbDNAstring), dataAgg[,1])

# Very Important
# THE ORDER OF THESE TWO COLUMNS SHOULD BE THE SAME
# SEQUENCES WILL BE OFF IF NOT
write.table(checkOrder, 
            file = paste(sharedPath, idFolder, "CHECK ORDER OF FASTA file AND BLAST TABLE.csv", 
                         sep = ""), 
            append = FALSE, 
            sep = ",", 
            col.names = NA)
```

From here: 
http://stackoverflow.com/questions/13545547/how-to-write-a-data-frame-with-one-column-a-list-to-a-file
```{r}
library("xlsx")

dataset2 <- dataAgg # make a copy just to be on the safe side
dataset2[sapply(dataset2, is.list)] <- 
    sapply(dataset2[sapply(dataset2, is.list)], 
           function(x)sapply(x, function(y) paste(unlist(y), collapse = ", ")))

write.xlsx(dataset2, file = paste(sharedPath, idFolder, "/to check BLAST results table.xlsx", sep = ""), 
           sheetName = "Sheet1", 
           col.names = TRUE, 
           row.names = TRUE, 
           append    = FALSE, 
           showNA    = TRUE)

attributes(gbDNAstring)

```

Trim
```{r}

#i <- 8

xTrim <- gbDNAstring

for(i in 1:length(xTrim)) { 
    if (dataAgg$sense[i] == 1) { 
        xTrim[i] <- DNAStringSet(xTrim[i], start = dataAgg$min[i], 
                                 end = dataAgg$max[i], width = NA, use.names = TRUE) 
        print(c(i, dataAgg$sense[i])) 
        } else { 
            if (dataAgg$sense[i] == -1) {  
                xTrim[i] <- reverseComplement(DNAStringSet(xTrim[i], start = dataAgg$min[i], 
                                                           end = dataAgg$max[i], width = NA, 
                                                           use.names = TRUE)) 
                print(c(i, dataAgg$sense[i])) 
                } else { 
                    xTrim[i] <- DNAStringSet("NNNN") 
                    print(c(i, "NNNN")) 
                    } 
            } 
    }

# Show outliers
meanLength  <- mean(width(xTrim), trim = 0.05)
queryLength <- mean(nchar(fastaForGenBank))

```

This module is to fix the GenBank output
```{r}

library("stringr")

gbNames <- names(xTrim)

# This is a loop to make some taxonomy glitches replacement to make the parsing with space accurate
   for(i in 1:length(gbNames)) {
     # This is to replace abbreviations like "R.secalis" in GenBank
       regexp1 <- " ([[:upper:]]{1})(\\.)([[:lower:]]+) "
       replacement1 <- str_extract(gbNames[i],regexp1)
       replacement1 <- sub("\\.", " ", replacement1, ignore.case = FALSE)
       gbNames[i] <- sub(" ([[:upper:]]{1})(\\.)([[:lower:]]+) ", replacement1, gbNames[i], ignore.case = FALSE)
    # This is to replace " f. sp. " for "_f._sp._"   
    #   string <- "Marssonina brunnea f. sp. multigermtubi MB_m1 tubulin beta chain (MBM_05801), mRNA"
       regexp2 <- " ([[:lower:]]+) f. sp. (\\'?)([[:lower:]]+)(\\'?) "
       replacement2 <- str_extract(gbNames[i],regexp2)
       replacement2 <- sub(" f. sp. ", "_.f._sp._", replacement2, ignore.case = FALSE)
       gbNames[i] <- sub(" ([[:lower:]]+) f. sp. (\\'?)([[:lower:]]+)(\\'?) ", replacement2, gbNames[i], ignore.case = FALSE)
   }
  

gbNames <- sub(" ", "|", gbNames, ignore.case = FALSE)
gbNames <- sub(" ", "|", gbNames, ignore.case = FALSE)
gbNames <- sub(" ", "|", gbNames, ignore.case = FALSE)


# *** Over here!!! This doesn't work...
parsedCol <- data.frame(matrix(unlist(strsplit(as.character(gbNames), "\\|")), 
                               nrow  = length(gbNames), 
                               byrow = T),
                        stringsAsFactors = FALSE)


# This is a loop to make extract strain numbers.  There are two approaches, one when there is "strain|isolate|voucher" and one 
# where the strain number is right after species of f.sp. name.  This may need to be tweaked for different strain codes
  for(i in 1:length(parsedCol$X8)) {
      if  (grepl("strain|isolate|voucher", parsedCol$X8[i])) {   
        regexp <- "(strain|isolate|voucher) ([[:alpha:]]*)( ?|\\-*|\\_*)([[:digit:]]*|[[:upper:]]*)(\\.*|\\-*)([[:digit:]]*|[[:upper:]]*)"
        parsedCol$strain[i] <- str_extract(parsedCol$X8[i],regexp)
      } else {
        # the trick for this was to leave a blank when there is no strain number
        regexp <- "([[:upper:]]*)( ?|\\-*|\\_*)([[:digit:]]*|[[:upper:]]*)(\\.*|\\-*)([[:digit:]]*|([[:alpha:]]+[[:digit:]]+))"
        parsedCol$strain[i] <- str_extract(parsedCol$X8[i],regexp) } 
    }

# remove strain|isolate|voucher in strain codes
parsedCol$strain2 <- sub("strain |isolate |voucher ", "", parsedCol$strain, ignore.case = FALSE)
parsedCol$strain2 <- sub("_", "", parsedCol$strain2, ignore.case = FALSE)
parsedCol$strain2 <- sub(" ", "", parsedCol$strain2, ignore.case = FALSE)
parsedCol$GB <- sub("\\.[[:digit:]]", "", parsedCol$X4, ignore.case = FALSE)
parsedCol$GB <- sub("_", "", parsedCol$GB, ignore.case = FALSE)
parsedCol$species <- gsub("_", "", parsedCol$X7, ignore.case = FALSE)
#for_names <- paste(parsedCol$X6,"_",parsedCol$species,"_",parsedCol$GB,"_strain(",parsedCol$strain2,")", sep = "")
names(x_trim) <- paste(parsedCol$X6,"_",parsedCol$species,"_",parsedCol$GB,"_strain(",parsedCol$strain2,")", sep = "")

writeXStringSet(x_trim, file="new_names.fasta", append=FALSE, format="fasta") 



```


Calculate a confidence interval based on all sequences
```{r}
library("chemometrics")

confInterv <- 2*sd_trim(width(xTrim), trim=0.05, const=FALSE)

# Show the sequences that will be removed
toRemove <- xTrim[(width(xTrim) < queryLength - 1*confInterv | width(xTrim) > queryLength + 2*confInterv), ]
toRemove <- xTrim[(width(xTrim) < meanLength - 10*confInterv | width(xTrim) > meanLength + 10*confInterv), ]

length(toRemove)
names(toRemove)

# Write file with removed sequences
writeXStringSet(toRemove, file = paste(sharedPath, idFolder, "GB_removed.fasta", sep = ""), 
                append = FALSE, format = "fasta") 

# Create the file without the outliers
xtrimNoOutliers <- xTrim[!names(xTrim) %in% names(toRemove)]
length(xtrimNoOutliers)

# Write fasta file of trimmed sequences
writeXStringSet(xtrimNoOutliers, 
                file = paste(sharedPath, idFolder, "GB_csv_extracted.fasta", sep = ""), 
                append = FALSE, format = "fasta") 


cmd2 <- paste("cat ",  
              sharedPath, idFolder, "query_aligned_fasta.fasta", " ",
              sharedPath, idFolder, "GB_csv_extracted.fasta > ",  
              sharedPath, idFolder, "to_align.fasta", 
              sep = "")
system(cmd2)
```

Do MAFFT alignement of sequences

Previous Note (not for this round for chunk):
Here I left out my query sequence because it is over 3000 bp, while the mean length of all the 
hits is 1300 bp. Keeping my query results in losing over 95% of the sequences in the toRemove 
block above. I did see that there is a sequence in the genBank match fasta file with 100% similarity 
to my query sequence. Because of this I know my query is in there.... for what reason should I 
not do this?
```{r}
# prefix <- "C_alignFasta"
prefix <- "old2_C_alignFasta"
prefix <- "old2_Ca_alignFasta_MAFFT_auto"
prefix <- "old2_Cb_alignFasta_MAFFT_INSI"
prefix <- "old2_Cc_alignFasta_MAFFT_INSI_max_iterate1000"
prefix <- "old2_Cd_alignFasta_MAFFT_EINSI_max_iterate1000"

cmd3 <- paste("/opt/bio/mafft/bin/mafft --auto --reorder ",  
              # sharedPath, idFolder, "to_align.fasta > ", 
              sharedPath, idFolder, "old2/", "unique_sequences_from_All_files_aligned.fasta > ", 
              # sharedPath, idFolder, "All_files_aligned.fasta",
              sharedPath, idFolder, "old2/", "old2_Ca_unique_sequences_All_files_aligned.fasta",
              sep = "")

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd3, prefix, suffix)

cmd4 <- paste("/opt/bio/mafft/bin/mafft -h ")
system(cmd4)
```

Check if the qsub job is still running:
```{r}

system("/opt/gridengine/bin/linux-x64/qstat")

```

Clean-up step: Remove the output files while keeping the qsub and bash file:
```{r}

RemoveQsubTempFiles(sharedPathAn, prefix)

```


**** Error over here - when I run line: 
maxV <- max(rowSums(dm), na.rm = TRUE)
Warning message: 
In max(rowSums(dm), na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf
```{r}
library("ape")
alignmentFile2 <- paste(sharedPath, idFolder, "All_files_aligned.fasta", sep = "")
align  <- read.dna(alignmentFile2, format = "fasta")

# Raw distance is p-distance with substitution -> d: transition + transversion
dm   <- dist.dna(align, model = "raw", pairwise.deletion = TRUE, as.matrix = TRUE)
tree <- njs(dm)
maxV <- max(rowSums(dm), na.rm = TRUE)

```

This is to get the root of the tree with the most distant species and generate nj tree
```{r}

myRoot <- which(rowSums(dm) == maxV)
max(dm, na.rm = TRUE)
nrow(dm)


tree <- njs(dm)
write.tree(tree, file = paste(sharedPath, idFolder, "nj_tree.newick", sep = ""), 
           append = FALSE, digits = 15, tree.names = FALSE)

# Code below doesn't work, because I have no root due to previous line not working.
pdf(file = paste(sharedPath, idFolder, "NJ_bionj_K80_tree_GenBank_and_ID_trimmed.pdf", sep = ""), 
    width = 8, height =36 )
 # "0.5-((nrow(dm)-50)/500)" is a rough equation to remove 0.1 to cex factor for every 50 taxa to keep font size small enough for larger data
  # if you want to have longer branches, reduce x.lim by 0.1 increments
  #plot.phylo(type = "phylogram", root(tree, my_root[1], node = NULL, resolve.root = TRUE), font=1, cex = 0.5,  x.lim = 0.7)
  plot.phylo(type = "phylogram", root(tree, myRoot[1], node = NULL, resolve.root = TRUE), font=1, 
      #       cex = 0.1,  x.lim = 0.07 + max(dm, na.rm = TRUE)/1.3, edge.width= 1.1 - (nrow(dm)/2000), no.margin=TRUE)
             cex = 0.54 - (sqrt(nrow(dm))/110),  x.lim = 0.07 + max(dm, na.rm = TRUE)/1.3, edge.width= 1.1 - (nrow(dm)/2000), no.margin=TRUE)
#cex = 0.54 - (sqrt(nrow(dm))/70),  x.lim = 0.07 + max(dm, na.rm = TRUE)/1.3, edge.width= 1.1 - (nrow(dm)/1200), no.margin=TRUE)
  title(main="", outer=FALSE, cex.main=1, font.main=2)
  dev.off()
```

****Over Here!!!

```{r}

lachWiiITS        <- readAAStringSet(paste(lachWiiITSFasta), format = "fasta")
names(lachWiiITS) <- "Lachnellula_willkommii-ITS"
fastaForGenBank   <- lachWiiITS

writeXStringSet(lachWiiITS, 
                file   = paste(genBankPath, "fasta_for_GenBank.fasta", sep = ""),
                append = FALSE, 
                format = "fasta")


```

If only one sequence start with this - I'm not sure how to work this....
```{r}
# # create text file from alignment
# align <- read.dna(paste(ID_Folder, "/", ID_fasta_files, sep =""), format="fasta", as.character = FALSE)
# # create text file from alignment
# align_txt <- sapply(align , function(x) toString(x))
# # remove all gaps, commas, and spaces
# align_txt <- as.character(gsub("-|,| ", "", align_txt))
# fasta_for_GenBank <- cbind(rownames(align), align_txt)
# rownames(fasta_for_GenBank) <- rownames(align)
```




















